package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.54

import (
	"context"
	"fmt"

	"github.com/zldobbs/ambrosia-server/graph/model"
)

// CreateIngredient is the resolver for the createIngredient field.
func (r *mutationResolver) CreateIngredient(ctx context.Context, input model.NewIngredient) (*model.Ingredient, error) {
	// Create ingredient
	row := r.DB_POOL.QueryRow(
		ctx,
		`
		INSERT INTO ingredient (name, description, user_id)
		VALUES ($1, $2, $3)
		RETURNING ingredient_id::TEXT
		`,
		input.Name,
		input.Description,
		input.UserID,
	)

	var ingredient_id string
	err := row.Scan(&ingredient_id)
	if err != nil {
		return nil, fmt.Errorf("failed to create ingredient from %v, error: %v", input, err)
	}

	// Fetch constructed ingredient
	row = r.DB_POOL.QueryRow(
		ctx,
		`
		SELECT i.ingredient_id, i.name, i.description, u.user_id, u.name
		FROM ingredient i
		JOIN user_account u ON i.user_id=u.user_id
		WHERE i.ingredient_id = $1
		`,
		ingredient_id,
	)

	// TODO: This method should be moved to database.go for re-use (ex: see Ingredients())
	var user model.User
	var ingredient model.Ingredient
	err = row.Scan(&ingredient.IngredientID, &ingredient.Name, &ingredient.Description, &user.UserID, &user.Name)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch newly created ingredient %v", err)
	}

	ingredient.User = &user

	return &ingredient, nil
}

// CreateRecipe is the resolver for the createRecipe field.
func (r *mutationResolver) CreateRecipe(ctx context.Context, input model.NewRecipe) (*model.Recipe, error) {
	panic(fmt.Errorf("not implemented: CreateRecipe - createRecipe"))
}

// Recipes is the resolver for the recipes field.
func (r *queryResolver) Recipes(ctx context.Context) ([]*model.Recipe, error) {
	panic(fmt.Errorf("not implemented: Recipes - recipes"))
}

// Ingredients is the resolver for the ingredients field.
func (r *queryResolver) Ingredients(ctx context.Context) ([]*model.Ingredient, error) {
	// Query database for all ingredients
	// TODO: Limit responses here, use pagination
	rows, err := r.DB_POOL.Query(
		ctx,
		`
		SELECT i.ingredient_id, i.name, i.description, u.user_id, u.name
		FROM ingredient i
		JOIN user_account u ON i.user_id = u.user_id
		`,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get ingredients froms server; error: %s", err)
	}

	var ingredients []*model.Ingredient
	for rows.Next() {
		var user model.User
		var ingredient model.Ingredient

		err := rows.Scan(&ingredient.IngredientID, &ingredient.Name, &ingredient.Description, &user.UserID, &user.Name)
		if err != nil {
			return nil, fmt.Errorf("failed to parse ingredients into struct; error: %s", err)
		}

		ingredient.User = &user
		ingredients = append(ingredients, &ingredient)
	}

	err = rows.Err()
	if err != nil {
		return nil, fmt.Errorf("failed to parse through returned SQL rows; error: %s", err)
	}

	return ingredients, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
