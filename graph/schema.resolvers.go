package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.54

import (
	"context"
	"fmt"
	"log"

	"github.com/zldobbs/ambrosia-server/graph/model"
)

// CreateIngredient is the resolver for the createIngredient field.
func (r *mutationResolver) CreateIngredient(ctx context.Context, input model.NewIngredient) (*model.Ingredient, error) {
	// TODO: Need to get consistent around how to use pgx
	// 	- Also, the GQL schema models likely need updating to properly serialize against the SQL column names
	// could maybe get away with using SQL aliases instead? Or look at the `db:` specifier on go structs, idk how to get this on the model itself.

	// Create ingredient
	ingredient_insert_row := r.DB_POOL.QueryRow(
		context.Background(),
		"INSERT INTO ingredient (name, description, user_id) VALUES ($1, $2, $3) RETURNING ingredient_id::TEXT",
		input.Name,
		input.Description,
		input.UserID,
	)

	var ingredient_id string
	err := ingredient_insert_row.Scan(&ingredient_id)
	if err != nil {
		log.Println(fmt.Errorf("Failed to create ingredient from %v, error: %v", input, err))
		return nil, err
	}

	// Fetch constructed ingredient
	ingredient_query_row := r.DB_POOL.QueryRow(
		context.Background(),
		"SELECT u.user_id, u.name, i.ingredient_id, i.name, i.description FROM ingredient i JOIN user_account u ON i.user_id=u.user_id WHERE i.ingredient_id = $1",
		ingredient_id,
	)

	// TODO: This feels unnecessary, have to be an easier way to exchange this data
	// Or should at least use the db: specifier?
	type UserIngredientCombo struct {
		UserID                string
		UserName              string
		IngredientID          string
		IngredientName        string
		IngredientDescription string
	}

	// Make sure to initialize a struct before trying to read data in or it will cause a nil pointer error!
	user_ingredient_combo := &UserIngredientCombo{}
	err = ingredient_query_row.Scan(
		&user_ingredient_combo.UserID,
		&user_ingredient_combo.UserName,
		&user_ingredient_combo.IngredientID,
		&user_ingredient_combo.IngredientName,
		&user_ingredient_combo.IngredientDescription,
	)
	if err != nil {
		log.Println(fmt.Errorf("Failed to fetch newly created ingredient %v", err))
		return nil, err
	}

	user := model.User{UserID: user_ingredient_combo.UserID, Name: user_ingredient_combo.UserName}
	ingredient := model.Ingredient{IngredientID: ingredient_id, Name: user_ingredient_combo.IngredientName, Description: user_ingredient_combo.IngredientDescription, User: &user}

	return &ingredient, nil
}

// CreateRecipe is the resolver for the createRecipe field.
func (r *mutationResolver) CreateRecipe(ctx context.Context, input model.NewRecipe) (*model.Recipe, error) {
	panic(fmt.Errorf("not implemented: CreateRecipe - createRecipe"))
}

// Recipes is the resolver for the recipes field.
func (r *queryResolver) Recipes(ctx context.Context) ([]*model.Recipe, error) {
	panic(fmt.Errorf("not implemented: Recipes - recipes"))
}

// Ingredients is the resolver for the ingredients field.
func (r *queryResolver) Ingredients(ctx context.Context) ([]*model.Ingredient, error) {
	panic(fmt.Errorf("not implemented: Ingredients - ingredients"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
